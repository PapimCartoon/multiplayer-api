#summary An insecure multiplayer API

The communication between your game and our server is done by writing a class that extends `ClientGameAPI.as`, and instantiating one instance of your class.

`ClientGameAPI` does not inherit from any other class.
If you want your class to extend an extra class (in addition to `ClientGameAPI`), 
then you can modify `ClientGameAPI` and make it inherit from the extra class.
For example, if you want your class to extend `MovieClip` then you can modify `ClientGameAPI` like this:
{{{
... ClientGameAPI extends MovieClip ...
}}}

The functions in `ClientGameAPI` can be divided into two categories: Operations and Callbacks.
We write `Array/*int*/` to denote an `Array` that contains only `int` objects;
Similarly, `Array/*String*/` is an `Array` that contains only `String` objects.

Auxiliary classes 
{{{
class ServerEntry { var key:String, var value:Object, var storedByUserId:int, var authorizedUserIds:Array/*int*/, var changedTimeInMilliSeconds:int; }
class UserEntry{var key:String, var value:Object, var isSecret:Boolean = false;}
class PlayerMatchOver { var player_id:int, score:int, pot_percentage:int; }
class RevealEntry{var key:String, var userIds:Array/*int*/ = null, var depth:int = 1;}
}}}
Operations are functions starting with `do`

The Operations are devided into two groups as well:

`do` operations which may be called by a single player
{{{
doRegisterOnServer()
doStoreState(userEntries:Array/*UserEntry*/)
doTrace(function_name:String, message:Object)
}}}

and `doAll` operations which have to be called by all players
{{{
doAllRequestRandomState(key:String, isSecret:Boolean = false)
doAllShuffleState(keys:Array/*String*/)
doAllRequestStateCalculation(keys:Array/*String*/)
doAllStoreStateCalculation(userEntries:Array/*UserEntry*/)
doAllRevealState(revealEntries:Array/*RevealEntry*/)
doAllSetTurn(userId:int, milliSecondsInTurn:int = -1)
doAllStoreState(userEntries:Array/*UserEntry*/)
doAllEndMatch(finishedPlayers:Array/*PlayerMatchOver*/)
doAllFoundHacker(userId:int, errorDescription:String)
}}}

Callbacks are functions starting with `got`
{{{

gotCustomInfo(infoEntries:Array/*InfoEntry*/) 
gotStateChanged(serverEntries:Array/*ServerEntry*/) 
gotRequestStateCalculation(serverEntries:Array/*ServerEntry*/)
gotKeyboardEvent(isKeyDown:Boolean, charCode:int, keyCode:int, keyLocation:int, altKey:Boolean, ctrlKey:Boolean, shiftKey:Boolean)
gotMatchEnded(finishedPlayerIds:Array/*int*/)
gotMatchStarted(allPlayerIds:Array/*int*/, finishedPlayerIds:Array/*int*/, extraMatchInfo:Object, matchStartedTime:int, serverEntries:Array/*ServerEntry*/)
gotMyUserId(myUserId:int)
gotUserDisconnected(userId:int)
gotUserInfo(userId:int, infoEntries:Array/*InfoEntry*/)
}}}

Operations are functions that your _game_ may call,
and callbacks are functions that the _container_ may call on your game.
Your class may override some of the callbacks and respond appropriately to them; it is not mandatory to override _all_ the callbacks.

You may call an operation only when the game is in progress,
i.e., there is a player that haven't finished playing.

=== High level description of the functions === 

|| *Function* || *Description* ||
|| [doRegisterOnServer] || Call it after your _game_ finished loading ||
|| [doStoreState] || Call it to store/update/delete you match state ||
|| [doTrace] || Call it to store traces to help you debug your application in the emulator and online ||
|| [doAllRequestRandomState] || Call to recive a randoom state ||
|| [doAllShuffleState] || Call to shuffle a set of ServerEntries||
|| [doAllRequestStateCalculation] || Call to request secret calculations ||
|| [doAllRequestStateCalculation doAllStoreStateCalculation] || Call to store calculations made by the calculator ||
|| [doAllRevealState] || Call to reveal a secret ServerEntry to a player ||
|| [doAllSetTurn] || Call to set next palyer turn ||
|| [doAllStoreState] || Call it to store/update/delete you match state unanimously ||
|| [doAllEndMatch] || Call it to end the match. The match will be over when all players called it ||
|| [doAllFoundHacker] || Call when one of the users has detected a hacker ||
|| [gotCustomInfo] || Called to pass custom info, e.g., url of a logo for branding your game, seconde per turn etc. ||
|| [doStoreState gotStateChanged] || Called when a user changed the match state ||
|| [doAllRequestStateCalculation gotRequestStateCalculation] || Called when users request `doAllRequestStateCalculation`||
|| [gotKeyboardEvent] || Called to pass keyboard down events (see KeyboardEvent) ||
|| [gotMatchOver] || Called when the match is over ||
|| [gotMatchStarted] || Called when a match starts ||
|| [gotMyUserId] || Called to pass your user_id ||
|| [gotUserDisconnected] || Called to inform that the user disconnected ||
|| [gotUserInfo] || Called to pass user specific info, e.g., user name or avatar ||



=== Initialization: order of the first callbacks === 
The first callback is `gotMyUserId`,
then you may get `gotCustomInfo` and `gotUserInfo`.
Then, when a match starts you will get `gotMatchStarted`.

=== Viewers and players === 
The set of connected users is partitioned into players and viewers.
New players cannot join an existing match; players may only leave the match (either by disconnecting or losing/winning the match).
When a player leaves the match (e.g., by winning or choosing to lose) he becomes a viewer.

Viewers should call the `doAll_*` operations along with all the players.


=== Serialization ===
This remark is relevant to functions with parameters of type `Object` or `Array/*Object*/`.
Objects are serialized when sent to the server, and therefore must contain only standard types: `Array`, `int`, `Number` (double-precision), `Boolean`, or `String`.
Important note: an `Array` may not contain anything except the above standard types.
You may not pass any other classes.

=== Harming the server ===
Come2Play have several mechanisms to protect its servers from bad game developers:
 * Spamming protection
 * Limiting the size of the match state

To avoid overloading the server, you can send at most 10 operations every second.
The message size should generally be smaller than 1KB (and must always be smaller than 10KB!).

To avoid running out of memory on the server,
and the total memory of the map is limited to 1MB.
The Come2Play platform tracks the maximum match state that your game uses,
and automatically sends the game developer warning when the game is about to reach the maximum match state.



=== Saved matches ===
The users may agree to save their match, and may decide to load it later.
A saved match contains the following information:
  * the game name (in the emulator we use the SWF name as the identifier for the game)
  * match state (user ids, keys, values)
  * ids of current players and the ids of players that already ended the match

Note that the following is not saved and should be restarted after the match is loaded:
  * who has the current turn,
  * the timers.