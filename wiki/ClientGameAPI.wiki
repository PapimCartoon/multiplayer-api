#summary An insecure multiplayer API

The communication between your game and our server is done by writing a class that extends `ClientGameAPI.as`, and instantiating one instance of your class.

`ClientGameAPI` does not inherit from any other class.
If you want your class to extend an extra class (in addition to `ClientGameAPI`), 
then you can modify `ClientGameAPI` and make it inherit from the extra class.
For example, if you want your class to extend `MovieClip` then you can modify `ClientGameAPI` like this:
{{{
... ClientGameAPI extends MovieClip ...
}}}

The functions in `ClientGameAPI` can be divided into two categories: Operations and Callbacks.
We write `Array/*int*/` to denote an `Array` that contains only `int` objects;
Similarly, `Array/*String*/` is an `Array` that contains only `String` objects.

Auxiliary classes (`secret_level` is explained in [SecureClientGameAPI]):
{{{
class Entry { var key:String, value:Object, secret_level:EnumSecretLevel; }
class UserEntry extends Entry { var user_id:int; }
class PlayerMatchOver { var player_id:int, score:int, pot_percentage:int; }
}}}
Operations are functions starting with `do_`
{{{
do_register_on_server()
do_store_trace(function_name:String, argument:Object)
do_agree_on_match_over(finished_players:Array/*PlayerMatchOver*/)
do_start_my_turn()
do_end_my_turn(next_turn_of_player_ids:Array/*int*/)
do_client_protocol_error_with_description(error_description:String)
do_store_match_state(entries:Array/*Entry*/)
do_send_message(to_user_ids:Array/*int*/, value:Object)
}}}
Callbacks are functions starting with `got_`
{{{
got_keyboard_event(is_key_down:Boolean, charCode:int, keyCode:int, keyLocation:int, altKey:Boolean, ctrlKey:Boolean, shiftKey:Boolean)
got_error(in_function_name:String, err:Error)
got_general_info(entries:Array/*Entry*/)  
got_user_info(user_id:int, entries:Array/*Entry*/) 
got_user_disconnected(user_id:int)
got_my_user_id(my_user_id:int) 
got_match_started(all_player_ids:Array/*int*/, finished_player_ids:Array/*int*/, extra_match_info:Object, match_started_time:int, match_state:Array/*UserEntry*/)
got_match_over(finished_player_ids:Array/*int*/)
got_start_turn_of(user_id:int)
got_end_turn_of(user_id:int)  
got_stored_match_state(user_id:int, entries:Array/*Entry*/)
got_message(user_id:int, value:Object)
}}}

Operations are functions that your _game_ may call,
and callbacks are functions that the _container_ may call on your game.
Your class may override some of the callbacks and respond appropriately to them; it is not mandatory to override _all_ the callbacks.

You may call an operation only when the game is in progress,
i.e., there is a player that haven't finished playing.

=== High level description of the functions === 

|| *Function* || *Description* ||
|| [do_register_on_server] || Call it after your _game_ finished loading ||
|| [do_store_trace] || Call it to store traces to help you debug your application in the emulator and online ||
|| [got_keyboard_event] || Called to pass keyboard down events (see KeyboardEvent) ||
|| [got_general_info] || Called to pass general info, e.g., url of a logo for branding your game ||
|| [got_user_info] || Called to pass user specific info, e.g., user name or avatar ||
|| [got_user_info got_user_disconnected] || Called to inform that the user disconnected ||
|| [got_my_user_id] || Called to pass your user_id ||
|| [got_match_started] || Called when a match starts ||
|| [do_agree_on_match_over] || Call it to end the match. The match will be over when all players called it ||
|| [got_match_over] || Called when the match is over ||
|| [do_store_match_state] || Call it to store/update/delete you match state ||
|| [do_store_match_state got_stored_match_state] || Called when a user changed the match state ||
|| [do_send_message] || Call it to send a message to a given set of users ||
|| [do_send_message got_message] || Called when a user get a message ||
|| [do_start_my_turn] || For Turn-based games. Call it to start your turn ||
|| [do_start_my_turn got_start_turn_of] || Called to acknowledge you have the turn ||
|| [do_start_my_turn do_end_my_turn] || Call it to end your turn, and set who may play next ||
|| [do_start_my_turn got_end_turn_of] || Called to acknowledge your turn ended ||
|| [got_error] || Called when one of the callbacks threw an error ||
|| [do_client_protocol_error_with_description] || Call it when you have to cancel the game due to an unrecoverable error ||

Read here about [Match_state_vs_messages Match state vs Sending messages].

=== Initialization: order of the first callbacks === 
The first callback is `got_my_user_id`,
then you may get `got_general_info` and `got_user_info`.
Then, when a match starts you will get `got_match_started`.
When a saved game is loaded, you may or may not get `got_start_turn_of`,
therefore one of the players (in a turn-based game) should call `do_start_my_turn` after getting `got_match_started`.


=== Viewers and players === 
The set of connected users is partitioned into players and viewers.
Viewers may not call all the operations and might have special restrictions when calling an operation.
New players cannot join an existing match; players may only leave the match (either by disconnecting or losing/winning the match).
When a player leaves the match (e.g., by winning or choosing to lose) he becomes a viewer, 
and all the viewer restrictions apply to him.

The following operations may only be called by players (not by viewers):
{{{
do_agree_on_match_over
do_start_my_turn
do_end_my_turn
do_client_protocol_error_with_description
}}}

A viewer may call:
{{{
do_send_message
do_store_trace
do_store_match_state
}}}
(Note that `do_store_match_state` have special limitations on viewers to prevent a viewer from tempering with the match state.)

=== Serialization ===
This remark is relevant to functions with parameters of type `Object` or `Array/*Object*/`.
Objects are serialized when sent to the server, and therefore must contain only standard types: `Array`, `int`, `Number` (double-precision), `Boolean`, or `String`.
Important note: an `Array` may not contain anything except the above standard types.
You may not pass any other classes.

=== Harming the server ===
Come2Play have several mechanisms to protect its servers from bad game developers:
 * Spamming protection
 * Limiting the size of the match state

To avoid overloading the server, you can send at most 10 operations every second.
The message size should generally be smaller than 1KB (and must always be smaller than 10KB!).

To avoid running out of memory on the server,
and the total memory of the map is limited to 1MB.
The Come2Play platform tracks the maximum match state that your game uses,
and automatically sends the game developer warning when the game is about to reach the maximum match state.



=== Saved matches ===
The users may agree to save their match, and may decide to load it later.
A saved match contains the following information:
  * the game name (in the emulator we use the SWF name as the identifier for the game)
  * match state (user ids, keys, values)
  * ids of current players and the ids of players that already ended the match

Note that the following is not saved and should be restarted after the match is loaded:
  * who has the current turn,
  * the timers.
