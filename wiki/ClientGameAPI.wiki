#summary A multiplayer API using only client-side code

The communication between your game and our server is done by writing a class that extends `ClientGameAPI.as`, and instantiating one instance of your class.

The functions in `ClientGameAPI` can be divided into two categories: Operations and Callbacks.
Operations are functions starting with `do_`
{{{
do_register_on_server()
do_store_trace(funcname:String, args:Object)
do_agree_on_match_over(user_ids:Array/*int*/, scores:Array/*int*/, pot_percentages:Array/*int*/)
do_start_my_turn()
do_end_my_turn(next_turn_of_player_ids:Array/*int*/)
do_client_protocol_error_with_description(error_description:Object)
do_store_match_state(key:String, value:Object)
do_send_message(to_user_ids:Array/*int*/, value:Object)
do_set_timer(key:String, in_seconds:int, pass_back:Object)
}}}
Callbacks are functions starting with `got_`
{{{
got_error(in_function_name:String, err:Error)
got_general_info(keys:Array/*String*/, values:Array/*Object*/)   
got_user_info(user_id:int, keys:Array/*String*/, values:Array/*Object*/)  
got_my_user_id(my_user_id:int) 
got_match_started(user_ids:Array/*int*/, extra_match_info:Object, match_started_time:int)
got_match_over(user_ids:Array/*int*/)
got_start_turn_of(user_id:int)
got_end_turn_of(user_id:int)  
got_stored_match_state(user_ids:Array/*int*/, keys:Array/*String*/, values:Array/*Object*/)
got_message(user_id:int, value:Object)
got_timer(from_user_id:int, key:String, pass_back:Object)  
}}}

Operations are functions that your _game_ may call,
and callbacks are functions that the _container_ may call on your game.
Your class may override some of the callbacks and respond appropriately to them; it is not mandatory to override _all_ the callbacks.

=== High level description of the functions === 

|| *Function* || *Description* ||
|| [do_register_on_server] || Call it after your _game_ finished loading ||
|| [do_store_trace] || Call it to store traces to help you debug your application in the emulator and online ||
|| [got_general_info] || Called to pass general info, e.g., url of a logo for branding your game ||
|| [got_user_info] || Called to pass user specific info, e.g., user name or avatar ||
|| [got_my_user_id] || Called to pass your user_id ||
|| [got_match_started] || Called when a match starts ||
|| [do_agree_on_match_over] || Call it to end the match. The match will be over when all players called it ||
|| [got_match_over] || Called when the match is over ||
|| [do_store_match_state] || Call it to store/update/delete you match state ||
|| [do_store_match_state got_stored_match_state] || Called when a user changed the match state ||
|| [do_send_message] || Call it to send a message to a given set of users ||
|| [do_send_message got_message] || Called when a user get a message ||
|| [do_set_timer] || Call it to set a timer on the server (similar to `setTimeout` in AS) ||
|| [do_set_timer got_timer] || Called on all users when when the timer ticks/expires ||
|| [do_start_my_turn] || For Turn-based games. Call it to start your turn ||
|| [do_start_my_turn got_start_turn_of] || Called to acknowledge you have the turn ||
|| [do_start_my_turn do_end_my_turn] || Call it to end your turn, and set who may play next ||
|| [do_start_my_turn got_end_turn_of] || Called to acknowledge your turn ended ||
|| [got_error] || Called when one of the callbacks threw an error ||
|| [do_client_protocol_error_with_description] || Call it when you have to cancel the game due to an unrecoverable error ||

Read here about [Match_state_vs_messages Match state vs Sending messages].


=== Viewers and players === 
The set of connected users is partitioned into players and viewers.
Viewers may not call all the operations and might have special restrictions when calling an operation.
New players cannot join an existing match; players may only leave the match (either by disconnecting or losing/winning the match).
When a player leaves the match he becomes a viewer.

The following operations may only be called by players (not by viewers):
{{{
do_agree_on_match_over
do_start_my_turn
do_end_my_turn
do_client_protocol_error_with_description
}}}

A viewer may call:
{{{
do_send_message
do_set_timer
do_store_trace
do_store_match_state
}}}
(Note that `do_store_match_state` have special limitations on viewers to prevent a viewer tempering with the match state.)

=== Serialization ===
This remark is relevant to functions with parameters of type `Object` or `Array/*Object*/`.
Objects are serialized when sent to the server, and therefore must contain only standard types: `Array`, `int`, `Boolean`, or `String`.
Important note: an `Array` may not contain anything except the above standard types.
You may not pass a floating point number (`Number`), or any other classes.

=== Spamming the server ===
To avoid overloading the server, you can send at most 10 operations every second.
The message size should generally be smaller than 1KB (and must always be smaller than 10KB!).

=== Saved games ===
About saved matches:
A saved match contains the following:
 * the game name (in the emulator we use the SWF name as the identifier for the game)
 * match state (users, keys, values)
 * user_ids are all players (including those that ended their match)
 * player_ids are those that are still playing
 * who has the current turn (a single user_id), or which users can have the next turn (next_turn_of_player_ids). Note that the current timers are lost!

When a saved match is loaded, the game the following callbacks:
 * got_match_started
 * got_match_over for those users that are no longer playing
 * got_stored_match_state with the match state
 * got_start_turn_of is there is a single player that has the turn or next_turn_of_player_ids is of size 1



= Operations and Callbacks =



<comment>
The first operation that your game should call is "do_register_on_server()".
Call it after your game SWF and any other resources finished loading completely.
The server may start a new match only after all players have called @do_register_on_server.
</comment>
<function>do_register_on_server()</function>

<comment>
@got_my_user_id is the first callback that is called.
It lets the game know what is the user_id of the user that is running this game.
Users can be partitioned into players and viewers.
Every user is identified by a unique user_id.
</comment>
<function>got_my_user_id(my_user_id:int)</function>

<comment>
If any of your callbacks have raised an error, that error is caught and ClientGameAPI will call @got_error.
In case of an error, you should call @do_client_protocol_error_with_description.
You should be very careful not to throw any exceptions in @got_error, because these exceptions will be silently ignored.
</comment>
<function>got_error(in_function_name:String, err:Error)</function>



<comment>
@got_general_info is used to pass parameters (key-value pairs) to the game.
These are the keys that are currently supported:
1) "logo_swf_full_url"
logo_swf_full_url is a full url (starting with "http://") 
that contains a logo in a flash SWF file of size 100x100 pixels, and it is vector based.

The game should place the logo in various places in the game
(e.g., in every square in a TicTacToe game, or on every Chess piece, etc)
Because the logo is vector based, it can be placed in a rectangular space of any size,
e.g., if you want to put the logo in a 40x40 space, 
then make sure that the movie clip (called "mc") that loads the logo has:
mc._xscale = 40;
mc._yscale = 40;
</comment>
<function>got_general_info(keys:Array/*String*/, values:Array/*Object*/)</function>

<comment>
@got_user_info is used to pass user info to the game; it will be called for each player and viewer of the game.

The keys that are currently supported:
1) "avatar_full_url"
Full url of the avatar of the user.
2) "nick_name"
The nick name of the user.
</comment>
<function>got_user_info(user_id:int, keys:Array/*String*/, values:Array/*Object*/)</function>


<comment>
@got_match_started is called when a new match has started.

@user_ids is the set of the user_id of the players.

If the game needs to make the same random choices in all the players (e.g., the order of a deck of cards),
then your game should use a random seed that is identical in all players.
You can use @match_started_time as such a random seed. 
If the match is saved and then loaded, the value of @match_started_time will be the same.

If your game has many versions, you may use @extra_match_info to pass your game extra parameters.
E.g., in the game of Go it can contain: the size of the board (9x9, 13x13, or 19x19), the komi, etc.
In the game of Puzzle it can be the picture domain (animal pictures, travel pictures, etc).
This mechanism is useful if you want to develop many variants of the same game.
With a single SWF you can create many game variants (by choosing different @extra_match_info for each game variant).
The @extra_match_info will be entered when you submit the game online, 
or in the emulator when you start a new match.
</comment>
<function>got_match_started(user_ids:Array/*int*/, extra_match_info:Object, match_started_time:int)</function>



<comment>
To end a match, all players must call @do_agree_on_match_over with the same exact parameters.

@user_ids is the set of the users that end the match.
In the common scenario, @user_ids contains all the players in the match.
However, it is possible that only a subset of the players end the match (but in any case, all players must call @do_agree_on_match_over).

@scores determines the score of each of the users ending the match.
The user with the highest score is the winner, and if all scores are identical than we have a tie.

@pot_percentages determines how the stake (or betting pot) should be divided among the players.
If @pot_percentages is null, then the users in @user_ids should get their stakes back (e.g., if the game was tied).
Otherwise, @pot_percentages[i] contains a number between 0 and 100, 
that represents the percentage of the pot that user @user_ids[i] should receive.

For example, suppose you have 3 players with user_ids=41, 42, 43. 
Suppose user_id=42 ended the match with score 90, and he should get 20% of the pot.
Then all the players (users 41, 42, 43) should call:
  do_agree_on_match_over([42], [90], [20])
Now users 41 and 43 continue to play, 
and the match is over with the score=100 to user_id=41, and score=10 to user_id=43,
and you wish to give 90% of the pot to user 41.
Then all players (users 41 and 43) should call:
  do_agree_on_match_over([41,43], [100,10], [90, 10])
</comment>
<function>do_agree_on_match_over(user_ids:Array/*int*/, scores:Array/*int*/, pot_percentages:Array/*int*/)</function>

<comment>
@got_match_over may be called if:
- the user disconnected, choose to lose, agree with the players that he can quit the game, etc.
  Note that we call got_match_over when a viewer disconnects as well.
- All the players called do_agree_on_match_over.
</comment>
<function>got_match_over(user_ids:Array/*int*/)</function>


<comment>
Some of the games developed are turn-based, i.e., the game proceeds in turns where in each given moment only
one player has the current turn. 
For example, Chess or Poker are turn-based games.
In contrast, Soccer is a real-time game where both players send commands to the server simultenously.
In the Come2Play platform, turn-based games may be played in turns using emails or other means.
For example, in a game of Chess, one player may make a turn, then the next player will get an email notification
and he may make the next turn, and so forth.

Turn-based games may use special functions to set who has the current turn, and who should play next.
The server has a single player that currently has the turn, or null if no one has the turn.
When no one has the turn, then some player may call @do_start_my_turn,
and the server will call @got_start_turn_of.
That player may later call @do_end_my_turn,
and the server will call @got_end_turn_of (and then no one has the turn).

@next_turn_of_player_ids are the players that may play next.
If @next_turn_of_player_ids is empty, then any player may call @do_start_my_turn.
Otherwise, only a player in @next_turn_of_player_ids may later call @do_start_my_turn.

The reason behind @next_turn_of_player_ids is for email-based games,
where only one player connects, makes a move, ends his turn, 
and the platform notifies the players in @next_turn_of_player_ids that they can make their next move.
</comment>
<function>do_start_my_turn()</function>
<function>do_end_my_turn(next_turn_of_player_ids:Array/*int*/)</function>
<function>got_start_turn_of(user_id:int)</function>
<function>got_end_turn_of(user_id:int)</function>


<comment>
ClientGameAPI is inherently insecure, because all the logic is on the client side.
In case of a protocol error (e.g., one of the players makes an illegal move),
you should call  @do_client_protocol_error_with_description.
The match will be canceled and the stakes will be returned back to the current players;
players that already finished playing before the error are not affected.

In the common scenario all the players will get their stakes back.
This is always the case of the number of players is 2.
However, there might be a rare scenario in games with more than 2 players, in which some of the players have already ended the match.
If there are players that finished playing before the call to @do_client_protocol_error_with_description
the remaining pot will be divided among the current players.
</comment>
<function>do_client_protocol_error_with_description(error_description:Object)</function>



<comment>
Use @do_store_match_state to store match state on the server.
Both players and viewers can store match state, and only when the match is in progress.
However, a viewer cannot override someone elses @key, whereas players can use the same key-space.
When the match ends, the state is cleared.

The match state is given to new viewers and new players before any other broadcast is sent to them.

To avoid running out of memory on the server,
the number of keys is limited to 1000,
and the total memory of the map is limited to 100KB.

To delete a key from the map, pass a value of null or ''.
</comment>
<function>do_store_match_state(key:String, value:Object)</function>
<function>got_stored_match_state(user_ids:Array/*int*/, keys:Array/*String*/, values:Array/*Object*/)</function>

<comment>
To send a message to set of users, call @do_send_message.

@to_user_ids is the set of users that should receive the message.
If @to_user_ids=null, then the message is sent to all users (both players and viewers).
Otherwise, the command will be sent to the users in @to_user_ids.

Note the difference between @do_store_match_state and @do_send_message:
Messages are not stored in the server memory, they are simply sent to the recipients.
Match-state is stored on the server, and when a new player/viewer connects, he gets the entire match state.
</comment>
<function>do_send_message(to_user_ids:Array/*int*/, value:Object)</function>
<function>got_message(user_id:int, obj:Object)</function>


<comment>
When a user calls @do_set_timer, the server will call @got_timer on **all** users after @in_seconds seconds passed.
After the user disconnects, his timers are be canceled.
You can have at most 100 concurrent timers (i.e., timers that have not yet ticked/expired).

If the same key is used by the same user, then the old timer is canceled.
Use a negative @in_seconds to cancel an old timer (use the same key).
Note that different users can use the same keys without interference.

</comment>
<function>do_set_timer(key:String, in_seconds:int, pass_back:Object)</function>
<function>got_timer(from_user_id:int, key:String, in_seconds:int, pass_back:Object)</function>


<comment>
Used to store traces to help debug the game.
Note that in the online version, we store only the last 100 traces (and discard old traces).
</comment>
<function>do_store_trace(functionName:String, args:Object)</function>