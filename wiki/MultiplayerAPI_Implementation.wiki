#summary The Multiplayer API implementation details using LocalConnection (the protocol between the game and the container).

We use LocalConnection to pass commands, therefore, there is a 40K limit on arguments to these methods.



In [TableOfContent Multiplayer API] section we explained that the API is a bridge between the _game_ (written by game developers) and the _container_ (written by the website hosting the game).
The game SWF is loaded by a _container_ that communicates with the _game_ 
using a LocalConnection. 
There are two issues:
  * how to determine the channel name that the container and game should use, and
  * how to translate objects of `Entry`, `UserEntry`, and `PlayerMatchOver`, to basic data types that are supported by LocalConnection.

The later question is easier to answer:
`BaseGameAPI` class translates these objects to basic data types, e.g., 
an array of `UserEntry` is translated to 3 arrays: 
user_ids of type `int[]`, keys of type `String[]`, and values of type `Object[]`.
These are the signatures of the translated functions:
{{{
do_finished_callback(method_name:String)
do_register_on_server(chanel:int)
do_store_trace(name:String, message:Object/*Serializable*/)
do_agree_on_match_over(player_ids:Array/*int*/, scores:Array/*int*/, pot_percentages:Array/*int*/)
do_start_my_turn()
do_end_my_turn(next_turn_of_player_ids:Array/*int*/)
do_store_match_state(key:String, value:Object/*Serializable*/)
do_send_message(to_user_ids:Array/*int*/, value:Object/*Serializable*/)
do_client_protocol_error_with_description(error_description:String)
do_connected_set_score(score:int)
do_connected_match_over(did_win:Boolean)
do_juror_store_match_state(secret_level:int, key:String, value:Object/*Serializable*/, for_user_id:int)
do_user_store_match_state(secret_level:int, key:String, value:Object/*Serializable*/)
do_juror_unfold_match_state(key:String, to_user_id:int)
do_juror_shuffle_match_state(keys:Array/*String*/)
do_juror_set_turn(turn_of_player_id:int)
do_juror_end_match(finished_player_ids:Array/*int*/, scores:Array/*int*/, pot_percentages:Array/*int*/)

got_keyboard_event(is_key_down:Boolean, charCode:int, keyCode:int, keyLocation:int, altKey:Boolean, ctrlKey:Boolean, shiftKey:Boolean)
got_general_info(keys:Array/*String*/, values:Array/*Serializable*/)
got_user_info(user_id:int, keys:Array/*String*/, values:Array/*Serializable*/)
got_user_disconnected(user_id:int)
got_my_user_id(my_user_id:int)
got_match_started(all_player_ids:Array/*int*/, finished_player_ids:Array/*int*/, extra_match_info:Object/*Serializable*/, match_started_time:int, user_ids:Array/*int*/, keys:Array/*String*/, values:Array/*Serializable*/)
got_match_over(finished_player_ids:Array/*int*/)
got_start_turn_of(user_id:int)
got_end_turn_of(user_id:int)
got_stored_match_state(user_id:int, key:String, value:Object/*Serializable*/)
got_message(user_id:int, value:Object/*Serializable*/)
got_secure_stored_match_state(secret_level:int, user_id:int, key:String, value:Object/*Serializable*/)
}}}
`do_finished_callback` is called by the game after every time the container calls some callback `got_*`.

The former question is slightly more complicated:
To make sure the container and game use the same LocalConnection channel, there is a _handshake_ protocol to determine the channel name.
This protocol supports multiple browser window or even multiple games in the same flash container. 
The communication protocol (hand-shake) between the game and container is described below.

The difficulty in the protocol is handling the case you have multiple _containers_, and that each _container_ may communicate with multiple _games_.
For example, suppose you open multiple emulator windows. Then you have multiple _containers_ (emulators), and in each emulator you have multiple _games_.

=== High level description of the protocol == 
Both _game_ and _container_ get the same parameter, and use this parameter to talk to one another. On this talk, the _container_ tells the _game_ what will be the channel name that they will use for all future communication.

The communication is two-way (thus we use two LocalConnection objects): the _game_ sends operations to the _container_, and the _container_ may call callbacks on the _game_.

=== Low level description of the protocol == 
First step: Determining `sPrefix`.
Both _game_ and _container_ get the same flashvar (or url) parameter:
`prefix=XXXX`. `XXXX` is either a number or a or the name of a javascript function. If it is a function, then we call that function (using `ExternalInterface.call` available from flash 8), and it should return a fixed number. For example, the function below returns a fixed random number:
{{{
var prefix_random_number = 1+ Math.ceil(1000000*Math.random());
function javascript_get_prefix_method() {
	return prefix_random_number;
}
}}}
We denote by `sPrefix` the number that is either `XXXX` or the number returned by the javascript function.
The reason we use a function name (instead of a number) is to allow the browser to cache the SWF file. If we had used a different number each time, then the browser won't cache the SWF file.

Second step:  Determining `iChanel`.
The _container_ connects to:
`"container_SWF"+sPrefix`

The _game_ calls (using the above connection name) `do_register_on_server(iChannel)`, where `iChannel` is a randomly chosen number

Final step: _game_ and _container_ communicate using two LocalConnection objects whose channel names are:
{{{
"DO_CHANEL" + sPrefix + "_" + iChanel
"GOT_CHANEL" + sPrefix + "_" + iChanel
}}}