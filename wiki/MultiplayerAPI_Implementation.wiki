#summary The Multiplayer API implementation details using LocalConnection (the protocol between the game and the container).

We use LocalConnection to pass commands, therefore, there is a 40K limit on arguments to these methods.


`do_finished_callback` is called by the game after every time the container calls some callback `got*`.


In [TableOfContent Multiplayer API] section we explained that the API is a bridge between the _game_ (written by game developers) and the _container_ (written by the website hosting the game).
The game SWF is loaded by a _container_ that communicates with the _game_ 
using a LocalConnection. 
There are two issues:
  * how to determine the channel name that the container and game should use, and
  * what happens to objects of type `ServerEntry`, `UserEntry`, 'RevealEntry', and `PlayerMatchOver` when they are passed over a LocalConnection?

The later question:
each class that we would like to pass over the LocalConnection must:
#be a Subclasses of SerializableClass
#have a constructor without arguments
#be a public class

it is important that all of the above will be followed, or else
none of the Classes will be transfered properly.

Good Example:

{{{
package somePackage {
  public class PublicClass1 extends SerializableClass {
  
    public static var staticVar:int; // static vars will NOT be serialized
    public var serializedField1:int;  
    private var serializedField2:int; // private vars will be serialized
    private var serializedField3:Array; // serialization is recursive, and goes into Arrays
    private var serializedField4:PublicClass2; // again, serialization is recursive
  
    // you must have a constructor without any arguments!
    public function PublicClass1() { 
      ...
    }

  }
}

}}}

{{{

package somePackage {
  public class PublicClass2 extends SerializableClass {
      ...
  }
}

}}}


 BAD Example:
 
 {{{
 
 package somePackage {
 
   public class PublicClass extends SerializableClass {
   
     // The constructor must not have any arguments!
     
     public function PublicClass(argument:int) {
       ...
     }
     ...
   }
 }
 
 class PrivateClass extends SerializableClass { 
   ...
 } 
 
 }}}
 
Explanation on why private classes cannot be serialized:
Only public should inherit from SerializableClass.
If the class is not public,
then flash chooses some random name for its package.
For example, in the BAD code above,
the qualified name of PrivateClass will be:
 PublicClass.as$54::PrivateClass
And this number may change, if you recompile a slightly modified code.
 
Explanation on the implementation of serialization:

- When an object is sent over a LocalConnection,
flash removes all type-information and turns that object into
a primitive object (that has only primitive types, Array and Object fields).

- When class A inherits from SerializableClass,
it gets the field __CLASS_NAME__, which is set in the constructor.

- When you deserialize an object, a new instance of the correct class
is created (that is why you must have an empty constructor),
and then we traverse and the object and set all the fields.
Note that  deserialize(object)  modifies the object.
 

The former question:
To make sure the container and game use the same LocalConnection channel, we use a flashvar parameter called `prefix`
to determine the channel name.
There is one channel for `do_` operations, and another for `got_` callbacks:
{{{
"DO_CHANEL_" + prefix
"GOT_CHANEL_" + prefix
}}}