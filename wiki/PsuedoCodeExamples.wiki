#summary Examples of games using ClientGameAPI

We give here examples of the pseudo code of the following games.
Turn-based games:
 * Public state: TicTacToe, 
 * Public state + Randomness: Backgammon, Roulette
 * Deterministic+secrets: Battleships, Startego, Diplomocy
 * Shuffles + secrets: Dominoes, Poker, Bridge, Clue (has several shuffles)
 * Randomness+secrets: Tanks (the wind is random, the secrets are the angle&speed of each shot)
 * "Server" side: Black Jack, Mine Sweeper, Sudoku  
Realtime games:
 * Trivia: series of questions, who answers correctly first wins the question. Limit the time for all players (if no one answered, go to the next question. if you answered incorrectly, the remaining player wins the question)
 * Snake
 
 
We use the following conventions:
 * the functions that start with `user` are called by the graphics (due to user interactions with the GUI).
 * the functions that start with `got` are called by the server.
 * the functions that start with `do` are sent to the server.

So this is the simplified version of `ClientGameAPI`:
{{{
// This pdseudo code is a simplified version:
// - It doesn't handle loading a saved game.
// - It doesn't handle the case where a player disconnects in the middle of a game.
// - The game ends for all players, i.e., when there is a winner the game ends for all players.
class SimplifiedClientGameAPI extends ClientGameAPI {
  var myUserId:int;
  var allPlayerIds:Array/*int*/;
  function assert(condition:Boolean):void {
    if (!condition) throw new Error();
  }
  function gotMyUserId(myUserId:int):void {
    this.myUserId = myUserId;
  }
  function gotMatchStarted(allPlayerIds:Array/*int*/, finishedPlayerIds:Array/*int*/, extraMatchInfo:Object/*Serializable*/, matchStartedTime:int, serverEntries:Array/*ServerEntry*/):void {
    this.allPlayerIds = allPlayerIds;
    gotMatchStarted2();
  }


  // subclasses of ClientGameAPI may override these callbacks.
  function gotMatchStarted2():void {}
  function gotStateChanged(serverEntries:Array/*ServerEntry*/):void {}  
  function gotRequestStateCalculation(serverEntries:Array/*ServerEntry*/):void {}
  
  // Subclasses of ClientGameAPI can call these operations.
  function doAllEndMatch(finishedPlayers:Array/*PlayerMatchOver*/):void { /* send operation to server */ }
  function doAllSetTurn(userId:int, milliSecondsInTurn:int):void { /* send operation to server */ }
  function doAllRevealState(revealEntries:RevealEntry[]):void { /* send operation to server */ }
  function doAllShuffleState(keys:String[]):void { /* send operation to server */ }
  function doAllFoundHacker(userId:int, errorDescription:String):void { /* send operation to server */ }
  function doAllRequestStateCalculation(keys:String[]):void { /* send operation to server */ }
  function doAllStoreStateCalculation(userEntries:UserEntry[]):void { /* send operation to server */ }
}
class RevealEntry {
  var key:String, userIds:Array/*int*/;
  function RevealEntry(key:String, userIds:Array/*int*/) {
    this.key = key;
    this.userIds = userIds;
}
}
class UserEntry {
  var key:String, value:Object, isSecret:boolean;
  function UserEntry(key:String, value:Object, isSecret:boolean) {
    this.key = key;
    this.value = value;
    this.isSecret = isSecret;
}
}
class ServerEntry {
  var key:String, value:Object, storedByUserId:int, authorizedUserIds:Array/*int*/;
  function isPublic():Boolean { return authorizedUserIds==null; }
}
class PlayerMatchOver {
  var playerId:int, score:int, potPercentage:int;
  function PlayerMatchOver(playerId:int, score:int, potPercentage:int) {
    this.playerId = playerId;
    this.score = score;
    this.potPercentage = potPercentage;
  }
}
}}}


= TicTacToe =

{{{
class TicTacToe extends ClientGameAPI {
  var turnNumber:int;
  
  function getTurnOfId():int {
    return allPlayerIds[turnNumber % allPlayerIds.length]; // round robin turns
  }
  function getEntryKey():String {
    return ""+turnNumber;
  }
  function isMyTurn():Boolean {
    return getTurnOfId()==myUserId;
  }
  
  function startMove():void {
    doAllSetTurn(getTurnOfId(), -1);
    if (isMyTurn()) {
      // allow the player to select his game move (row&col to place his marker)
    }
  }  
  function performMove(gameMove:GameMove):void {
    // update the logic and the graphics
    turnNumber ++; // advance the turn
    if (!isGameOver()) {
      startMove();
    } else {
      var finishedPlayers:Array/*PlayerMatchOver*/ = [];
      for each (var playerId:int in allPlayerIds) {
        var score:int, potPercentage:int;
        // set the score and potPercentage for playerId
        finishedPlayers.push( new PlayerMatchOver(playerId, score, potPercentage) );
      }
      doAllEndMatch(finishedPlayers);
    }
  }
  function userMadeHisMove(gameMove:GameMove):void {
    doStoreState([ new UserEntry(getEntryKey(), gameMove, false) ]);
    performMove(gameMove);
  }
  
  function gotMatchStarted2() {
    // init the logic and the graphics
    turnNumber = 0;
    startMove();
  }
  function gotStateChanged(serverEntries:Array/*ServerEntry*/):void {
    assert(serverEntries.length==1);
    var entry:ServerEntry = serverEntries[0];
    if (entry.storedByUserId==myUserId) return; // already updated my move
    assert(entry.storedByUserId==getTurnOfId());
    assert(entry.key==getEntryKey());
    assert(entry.isPublic());
    var gameMove:GameMove = GameMove.object2GameMove(entry.value);
    performMove(gameMove);
  } 
}

class GameMove {
  var row:int, column:int;
  function GameMove(row:int, column:int) {
    this.row = row;
    this.column = column;
  }
  static function object2GameMove(obj:Object):GameMove {
    this.row = obj["row"];
    this.column = obj["column"];
  }    
}
}}}


= Backgammon =
= Battleships =
= Dominoes =
= Mine Sweeper =
= Black Jack =
= Trivia =
= Snake =