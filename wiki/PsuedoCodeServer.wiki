#summary pseudo code representation of the server

{{{
// allPlayers is an array of all players.
var allPlayers:Array/*User*/ 
// a QueueEntry contains a message, which user sent it first, and an array of users for whom we wait.
class QueueEntry(fromUser:User, waitingForUsers:Array/*User*/, message:Message)
// waitingQueue contains messages that arrived and have not been processed yet.
var waitingQueue:Array/*QueueEntry*/ 
// unverifiedQueue contains messages that have been processed and have not been acknowledged/verified by all players.
var unverifiedQueue:Array/*QueueEntry*/ 

// gotUserMessage is called when a user sends a message to the server
function gotUserMessage(user:User,message:Message) {
	if (message is doTrace or doRegisterOnServer or doAllFoundHacker) {
	  processMessage(user, message)
	} else if (message is doFinishedCallback) {
	  var entry:QueueEntry = the first entry in unverifiedQueue, such that user is in entry.waitingForUsers
	  remove user from entry.waitingForUsers
	  if (entry.waitingForUsers is empty) {
	    // entry must be the head of unverifiedQueue
	    remove head of unverifiedQueue 
	    (in the server, we update the verified match state according to entry.message)
	    processWaitingQueue()
	  }
	} else {
	  // message is doStoreState or doAll*
	  var entry:QueueEntry;
	  var isNewEntry:Boolean = true
	  if (message is doStoreState) {
	    entry = new QueueEntry(user, [], message) // in doStoreState we do not wait for any other player
	  } else {
	    // a doAll* message
	    // check if other players already sent the same message
	    entry = the first entry in waitingQueue, such that user is in entry.waitingForUsers
	    if (entry is null) {
	      entry = new QueueEntry(user, allPlayers, message) // in doAll* we wait for all other players
	    } else {
	      isNewEntry = false
	      // entry.message must be a doAll* message, because waitingForUsers is not empty (and in doStoreState it is always empty) 
	      if (entry.message is not equal to message) { // we check both message name and parameters
	        report error (in the server, we use the jury system to find if there is a hacker)
	      }
	    }
	    remove user from entry.waitingForUsers
	  }
	  if (isNewEntry) {
	    waitingQueue.push( entry )
	  }
	  processWaitingQueue()
	}
}

// this function processes the messages in waitingQueue
function processWaitingQueue() {
	while (true) {
	  if (waitingQueue is empty) return
	  var entry:QueueEntry = head of waitingQueue
	  var message:Message = entry.message;
	  if (entry.waitingForUsers is not empty) return
	  remove head of waitingQueue 
	  if (message is not doAllSetTurn) { // doAllSetTurn is the only doAll* that doesn't change the match state
	    unverifiedQueue.push( new QueueEntry(null, allPlayers, message) )
	  }
	  processMessage(entry.fromUser, message) // update match state and broadcast gotStateChanged to all users
	}
}

// There is also a timer that checks that entries are removed from waitingQueue and unverifiedQueue (for guaranteeing progress).
// If a certain entry stays in a queue too long, we report an error and use the jury system to find a hacker.
}}}

In the java server:
A new viewer will get the _match state_.
A jury member will get the _*verified* match state_, followed by all the unverified messages.
If all jury members agree on the hacker (or non-existence of one), then we have a hacker.
Otherwise it is a bug of the game developer.
